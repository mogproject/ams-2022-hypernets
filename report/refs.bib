

@article{Kirkland,
  title={Gram mates, sign changes in singular values, and isomorphism},
  author={Kim, Sooyeong and Kirkland, Steve},
  journal={Linear Algebra and its Applications},
  volume={644},
  pages={108--148},
  year={2022},
  publisher={Elsevier}
}

@article{Kirkland2017,
  title={Two-mode networks exhibiting data loss},
  author={Kirkland, Steve},
  journal={Journal of Complex Networks},
  volume={6},
  number={2},
  pages={297--316},
  year={2018},
  publisher={Oxford University Press}
}

@article{Everett,
  title={The dual-projection approach for two-mode networks},
  author={Everett, Martin G and Borgatti, Stephen P},
  journal={Social networks},
  volume={35},
  number={2},
  pages={204--210},
  year={2013},
  publisher={Elsevier}
}

@article{shaohan1988complexity,
  title={The complexity of the clique partition number problem},
  author={Shaohan, Ma and Wallis, W.D. and Wu Ju Lin},
  journal={Congr. Numer},
  volume={67},
  pages={59--66},
  year={1988}
}

% publisher = {Schloss Dagstuhl–Leibniz-Zentrum für Informatik},
%	editor = {Cao, Yixin and Pilipczuk, Marcin},
% note = {ISSN: 1868-8969},
@inproceedings{feldmann_fixed-parameter_2020,
	address = {Dagstuhl, Germany},
	series = {Leibniz {International} {Proceedings} in {Informatics} ({LIPIcs})},
	title = {Fixed-{Parameter} {Tractability} of the {Weighted} {Edge} {Clique} {Partition} {Problem}},
	volume = {180},
	isbn = {978-3-95977-172-6},
	url = {https://drops.dagstuhl.de/opus/volltexte/2020/13320},
	doi = {10.4230/LIPIcs.IPEC.2020.17},
	urldate = {2022-07-03},
	booktitle = {15th {International} {Symposium} on {Parameterized} and {Exact} {Computation} ({IPEC} 2020)},
	author = {Feldmann, Andreas Emil and Issac, Davis and Rai, Ashutosh},
	year = {2020},
	keywords = {Edge Clique Partition, fixed-parameter tractability, kernelization},
	pages = {17:1--17:16},
}

  month = jan,
@incollection{cooley_parameterized_2021,
	series = {Proceedings},
	title = {Parameterized algorithms for identifying gene co-expression modules via weighted clique decomposition},
	url = {https://epubs.siam.org/doi/10.1137/1.9781611976830.11},
	abstract = {In the Edge Clique Cover (ECC) problem, given an undirected graph \$G\$ and an integer \$k\$, we ask whether one can choose \$k\$ cliques in \$G\$ such that each edge of \$G\$ is contained in at least one of the chosen cliques. Gramm et al. [ACM J. Exp. Algorithmics,  13 (2008)] have shown a set of simple rules that reduce the number of vertices of \$G\$ to \$2{\textasciicircum}k\$ while preserving the answer to the instance at hand, that is, they have shown a kernel for the problem with at most \$2{\textasciicircum}k\$ vertices. No algorithm is known with significantly better running time bound than a brute-force search on this kernel. In this paper, we show that the approach of Gramm et al. is essentially optimal: we present a polynomial-time algorithm that reduces an arbitrary instance of \$3\$-CNF-SAT with \$n\$ variables and \$m\$ clauses to an equivalent ECC instance \$(G,k)\$ with \$k = {\textbackslash}mathcal\{O\}({\textbackslash}log n)\$ and \${\textbar}V(G){\textbar} = {\textbackslash}mathcal\{O\}(n + m)\$. Consequently, there is no \$2{\textasciicircum}\{2{\textasciicircum}\{o(k)\}\}\{{\textbackslash}rm poly\}(n)\$ time algorithm for the ECC problem, unless the Exponential Time Hypothesis fails. Moreover, our reduction also implies that, unless P \$ = \$ NP, the ECC problem does not admit a subexponential kernel, i.e., a kernel of size \$2{\textasciicircum}\{o(k)\}\$.},
	urldate = {2022-07-03},
	booktitle = {Proceedings of the 2021 {SIAM} {Conference} on {Applied} and {Computational} {Discrete} {Algorithms} ({ACDA21})},
	author = {Cooley, Madison and Greene, Casey S. and Issac, Davis and Pividori, Milton and Sullivan, Blair D.},
	publisher = {Society for Industrial and Applied Mathematics},
	year = {2021},
	doi = {10.1137/1.9781611976830.11},
	pages = {111--122},
}

	publisher = {arXiv},
	month = jan,
@misc{chen_symmetric_2022,
	title = {Symmetric {Sparse} {Boolean} {Matrix} {Factorization} and {Applications}},
	url = {http://arxiv.org/abs/2102.01570},
	abstract = {In this work, we study a variant of nonnegative matrix factorization where we wish to ﬁnd a symmetric factorization of a given input matrix into a sparse, Boolean matrix. Formally speaking, given M ∈ Zm×m, we want to ﬁnd W ∈ \{0, 1\}m×r such that M − WW⊤ 0 is minimized among all W for which each row is k-sparse. This question turns out to be closely related to a number of questions like recovering a hypergraph from its line graph, as well as reconstruction attacks for private neural network training.},
	language = {en},
	urldate = {2022-07-02},
	author = {Chen, Sitan and Song, Zhao and Tao, Runzhou and Zhang, Ruizhe},
	year = {2022},
  note = {arXiv:2102.01570 [cs, stat]},
	keywords = {Computer Science - Data Structures and Algorithms, Computer Science - Cryptography and Security, Computer Science - Machine Learning, Statistics - Machine Learning},
	annote = {Comment: 33 pages, to appear in Innovations in Theoretical Computer Science (ITCS 2022), v2: updated refs},
}

	month = oct,
@article{roussopoulos_max_1973,
	title = {A max \{m,n\} algorithm for determining the graph {H} from its line graph {G}},
	volume = {2},
	issn = {0020-0190},
	doi = {10.1016/0020-0190(73)90029-X},
	abstract = {The maximum/minimum bisection problems are, given an edge-weighted graph, to find a bipartition of the vertex set into two sets whose sizes differ by at most one, such that the total weight of edges between the two sets is maximized/minimized. Although these two problems are known to be NP-hard, there is an efficient algorithm for bounded-treewidth graphs. In particular, Jansen et al. (2005) [5] gave an O(2tn3){\textless}math{\textgreater}{\textless}mi is="true"{\textgreater}O{\textless}/mi{\textgreater}{\textless}mo stretchy="false" is="true"{\textgreater}({\textless}/mo{\textgreater}{\textless}msup is="true"{\textgreater}{\textless}mrow is="true"{\textgreater}{\textless}mn is="true"{\textgreater}2{\textless}/mn{\textgreater}{\textless}/mrow{\textgreater}{\textless}mrow is="true"{\textgreater}{\textless}mi is="true"{\textgreater}t{\textless}/mi{\textgreater}{\textless}/mrow{\textgreater}{\textless}/msup{\textgreater}{\textless}msup is="true"{\textgreater}{\textless}mrow is="true"{\textgreater}{\textless}mi is="true"{\textgreater}n{\textless}/mi{\textgreater}{\textless}/mrow{\textgreater}{\textless}mrow is="true"{\textgreater}{\textless}mn is="true"{\textgreater}3{\textless}/mn{\textgreater}{\textless}/mrow{\textgreater}{\textless}/msup{\textgreater}{\textless}mo stretchy="false" is="true"{\textgreater}){\textless}/mo{\textgreater}{\textless}/math{\textgreater}-time algorithm when given a tree decomposition of width t of the input graph, where n is the number of vertices of the input graph. Eiben et al. (2021) [10] improved the dependency of n in the running time by giving an O(8tt5n2log⁡n){\textless}math{\textgreater}{\textless}mi is="true"{\textgreater}O{\textless}/mi{\textgreater}{\textless}mo stretchy="false" is="true"{\textgreater}({\textless}/mo{\textgreater}{\textless}msup is="true"{\textgreater}{\textless}mrow is="true"{\textgreater}{\textless}mn is="true"{\textgreater}8{\textless}/mn{\textgreater}{\textless}/mrow{\textgreater}{\textless}mrow is="true"{\textgreater}{\textless}mi is="true"{\textgreater}t{\textless}/mi{\textgreater}{\textless}/mrow{\textgreater}{\textless}/msup{\textgreater}{\textless}msup is="true"{\textgreater}{\textless}mrow is="true"{\textgreater}{\textless}mi is="true"{\textgreater}t{\textless}/mi{\textgreater}{\textless}/mrow{\textgreater}{\textless}mrow is="true"{\textgreater}{\textless}mn is="true"{\textgreater}5{\textless}/mn{\textgreater}{\textless}/mrow{\textgreater}{\textless}/msup{\textgreater}{\textless}msup is="true"{\textgreater}{\textless}mrow is="true"{\textgreater}{\textless}mi is="true"{\textgreater}n{\textless}/mi{\textgreater}{\textless}/mrow{\textgreater}{\textless}mrow is="true"{\textgreater}{\textless}mn is="true"{\textgreater}2{\textless}/mn{\textgreater}{\textless}/mrow{\textgreater}{\textless}/msup{\textgreater}{\textless}mi is="true" mathvariant="normal"{\textgreater}log{\textless}/mi{\textgreater}{\textless}mo is="true"{\textgreater}⁡{\textless}/mo{\textgreater}{\textless}mi is="true"{\textgreater}n{\textless}/mi{\textgreater}{\textless}mo stretchy="false" is="true"{\textgreater}){\textless}/mo{\textgreater}{\textless}/math{\textgreater}-time algorithm. Moreover, they showed that there is no O(n2−ε){\textless}math{\textgreater}{\textless}mi is="true"{\textgreater}O{\textless}/mi{\textgreater}{\textless}mo stretchy="false" is="true"{\textgreater}({\textless}/mo{\textgreater}{\textless}msup is="true"{\textgreater}{\textless}mrow is="true"{\textgreater}{\textless}mi is="true"{\textgreater}n{\textless}/mi{\textgreater}{\textless}/mrow{\textgreater}{\textless}mrow is="true"{\textgreater}{\textless}mn is="true"{\textgreater}2{\textless}/mn{\textgreater}{\textless}mo linebreak="badbreak" linebreakstyle="after" is="true"{\textgreater}−{\textless}/mo{\textgreater}{\textless}mi is="true"{\textgreater}ε{\textless}/mi{\textgreater}{\textless}/mrow{\textgreater}{\textless}/msup{\textgreater}{\textless}mo stretchy="false" is="true"{\textgreater}){\textless}/mo{\textgreater}{\textless}/math{\textgreater}-time algorithm for trees under some reasonable complexity assumption.
In this paper, we show an O(2t(tn)2){\textless}math{\textgreater}{\textless}mi is="true"{\textgreater}O{\textless}/mi{\textgreater}{\textless}mo stretchy="false" is="true"{\textgreater}({\textless}/mo{\textgreater}{\textless}msup is="true"{\textgreater}{\textless}mrow is="true"{\textgreater}{\textless}mn is="true"{\textgreater}2{\textless}/mn{\textgreater}{\textless}/mrow{\textgreater}{\textless}mrow is="true"{\textgreater}{\textless}mi is="true"{\textgreater}t{\textless}/mi{\textgreater}{\textless}/mrow{\textgreater}{\textless}/msup{\textgreater}{\textless}msup is="true"{\textgreater}{\textless}mrow is="true"{\textgreater}{\textless}mo stretchy="false" is="true"{\textgreater}({\textless}/mo{\textgreater}{\textless}mi is="true"{\textgreater}t{\textless}/mi{\textgreater}{\textless}mi is="true"{\textgreater}n{\textless}/mi{\textgreater}{\textless}mo stretchy="false" is="true"{\textgreater}){\textless}/mo{\textgreater}{\textless}/mrow{\textgreater}{\textless}mrow is="true"{\textgreater}{\textless}mn is="true"{\textgreater}2{\textless}/mn{\textgreater}{\textless}/mrow{\textgreater}{\textless}/msup{\textgreater}{\textless}mo stretchy="false" is="true"{\textgreater}){\textless}/mo{\textgreater}{\textless}/math{\textgreater}-time algorithm for both problems, which is asymptotically tight to their conditional lower bound. We also show that the exponential dependency of the treewidth is asymptotically optimal under the Strong Exponential Time Hypothesis. Finally, we discuss the (in)tractability of both problems with respect to special graph classes.
A strong clique in a graph is a clique intersecting all inclusion-maximal stable sets. Strong cliques play an important role in the study of perfect graphs. We study strong cliques in the class of diamond-free graphs, from both structural and algorithmic points of view. We show that the following five NP-hard or co-NP-hard problems all remain NP-hard or co-NP-hard when restricted to the class of diamond-free graphs: Is a given clique strong? Does the graph have a strong clique? Is every vertex contained in a strong clique? Given a partition of the vertex set into cliques, is every clique in the partition strong? Can the vertex set be partitioned into strong cliques?
On the positive side, we show that the following three problems whose computational complexity is open in general can be solved in polynomial time in the class of diamond-free graphs: Does every induced subgraph have a strong clique? Is every maximal clique strong? Is every edge contained in a strong clique? The last two results are derived from a characterization of diamond-free graphs in which every maximal clique is strong, which also implies an improved Erdős-Hajnal property for such graphs.
The line graph of a graph G has one node per each edge of G, two of them being adjacent only when the corresponding edges have a node of G in common. In this work, we consider the problem of finding the minimum number of edges to delete so that the resulting graph is a line graph, which presents an interesting application in haplotyping of diploid organisms. We propose an Integer Linear Programming formulation for this problem. We compare our approach with the only other existing formulation for the problem and explore the possibility of combining both of them. Finally, we present a computational study to compare the different approaches proposed.
For a graph S{\textless}math{\textgreater}{\textless}mi is="true"{\textgreater}S{\textless}/mi{\textgreater}{\textless}/math{\textgreater}, a vertex with degree one in S{\textless}math{\textgreater}{\textless}mi is="true"{\textgreater}S{\textless}/mi{\textgreater}{\textless}/math{\textgreater} is an end-vertex of S{\textless}math{\textgreater}{\textless}mi is="true"{\textgreater}S{\textless}/mi{\textgreater}{\textless}/math{\textgreater} and an edge is a pendant edge if one of its ends is an end-vertex. A net N{\textless}math{\textgreater}{\textless}mi is="true"{\textgreater}N{\textless}/mi{\textgreater}{\textless}/math{\textgreater} is a graph obtained from a K3{\textless}math{\textgreater}{\textless}msub is="true"{\textgreater}{\textless}mrow is="true"{\textgreater}{\textless}mi is="true"{\textgreater}K{\textless}/mi{\textgreater}{\textless}/mrow{\textgreater}{\textless}mrow is="true"{\textgreater}{\textless}mn is="true"{\textgreater}3{\textless}/mn{\textgreater}{\textless}/mrow{\textgreater}{\textless}/msub{\textgreater}{\textless}/math{\textgreater} by adding a pendant edge at each vertex of the K3{\textless}math{\textgreater}{\textless}msub is="true"{\textgreater}{\textless}mrow is="true"{\textgreater}{\textless}mi is="true"{\textgreater}K{\textless}/mi{\textgreater}{\textless}/mrow{\textgreater}{\textless}mrow is="true"{\textgreater}{\textless}mn is="true"{\textgreater}3{\textless}/mn{\textgreater}{\textless}/mrow{\textgreater}{\textless}/msub{\textgreater}{\textless}/math{\textgreater}. A P6{\textless}math{\textgreater}{\textless}msub is="true"{\textgreater}{\textless}mrow is="true"{\textgreater}{\textless}mi is="true"{\textgreater}P{\textless}/mi{\textgreater}{\textless}/mrow{\textgreater}{\textless}mrow is="true"{\textgreater}{\textless}mn is="true"{\textgreater}6{\textless}/mn{\textgreater}{\textless}/mrow{\textgreater}{\textless}/msub{\textgreater}{\textless}/math{\textgreater} is a path on 6 vertices. In this paper, we solve two conjectures and prove that for 2-connected claw-free graphs H{\textless}math{\textgreater}{\textless}mi is="true"{\textgreater}H{\textless}/mi{\textgreater}{\textless}/math{\textgreater} and for a fixed graph S∈\{N,P6\}{\textless}math{\textgreater}{\textless}mrow is="true"{\textgreater}{\textless}mi is="true"{\textgreater}S{\textless}/mi{\textgreater}{\textless}mo linebreak="goodbreak" linebreakstyle="after" is="true"{\textgreater}∈{\textless}/mo{\textgreater}{\textless}mrow is="true"{\textgreater}{\textless}mo is="true"{\textgreater}\{{\textless}/mo{\textgreater}{\textless}mi is="true"{\textgreater}N{\textless}/mi{\textgreater}{\textless}mo is="true"{\textgreater},{\textless}/mo{\textgreater}{\textless}msub is="true"{\textgreater}{\textless}mrow is="true"{\textgreater}{\textless}mi is="true"{\textgreater}P{\textless}/mi{\textgreater}{\textless}/mrow{\textgreater}{\textless}mrow is="true"{\textgreater}{\textless}mn is="true"{\textgreater}6{\textless}/mn{\textgreater}{\textless}/mrow{\textgreater}{\textless}/msub{\textgreater}{\textless}mo is="true"{\textgreater}\}{\textless}/mo{\textgreater}{\textless}/mrow{\textgreater}{\textless}/mrow{\textgreater}{\textless}/math{\textgreater}, if the degree at each end-vertex of every induced copy of S{\textless}math{\textgreater}{\textless}mi is="true"{\textgreater}S{\textless}/mi{\textgreater}{\textless}/math{\textgreater} is at least ({\textbar}V(H){\textbar}−2)∕3{\textless}math{\textgreater}{\textless}mrow is="true"{\textgreater}{\textless}mrow is="true"{\textgreater}{\textless}mo is="true"{\textgreater}({\textless}/mo{\textgreater}{\textless}mrow is="true"{\textgreater}{\textless}mo is="true"{\textgreater}{\textbar}{\textless}/mo{\textgreater}{\textless}mi is="true"{\textgreater}V{\textless}/mi{\textgreater}{\textless}mrow is="true"{\textgreater}{\textless}mo is="true"{\textgreater}({\textless}/mo{\textgreater}{\textless}mi is="true"{\textgreater}H{\textless}/mi{\textgreater}{\textless}mo is="true"{\textgreater}){\textless}/mo{\textgreater}{\textless}/mrow{\textgreater}{\textless}mo is="true"{\textgreater}{\textbar}{\textless}/mo{\textgreater}{\textless}/mrow{\textgreater}{\textless}mo is="true"{\textgreater}−{\textless}/mo{\textgreater}{\textless}mn is="true"{\textgreater}2{\textless}/mn{\textgreater}{\textless}mo is="true"{\textgreater}){\textless}/mo{\textgreater}{\textless}/mrow{\textgreater}{\textless}mo is="true"{\textgreater}∕{\textless}/mo{\textgreater}{\textless}mn is="true"{\textgreater}3{\textless}/mn{\textgreater}{\textless}/mrow{\textgreater}{\textless}/math{\textgreater}, then H{\textless}math{\textgreater}{\textless}mi is="true"{\textgreater}H{\textless}/mi{\textgreater}{\textless}/math{\textgreater} is Hamiltonian. The case for S=N{\textless}math{\textgreater}{\textless}mrow is="true"{\textgreater}{\textless}mi is="true"{\textgreater}S{\textless}/mi{\textgreater}{\textless}mo linebreak="goodbreak" linebreakstyle="after" is="true"{\textgreater}={\textless}/mo{\textgreater}{\textless}mi is="true"{\textgreater}N{\textless}/mi{\textgreater}{\textless}/mrow{\textgreater}{\textless}/math{\textgreater} was conjectured by Broersma (1993); the case for S=P6{\textless}math{\textgreater}{\textless}mrow is="true"{\textgreater}{\textless}mi is="true"{\textgreater}S{\textless}/mi{\textgreater}{\textless}mo linebreak="goodbreak" linebreakstyle="after" is="true"{\textgreater}={\textless}/mo{\textgreater}{\textless}msub is="true"{\textgreater}{\textless}mrow is="true"{\textgreater}{\textless}mi is="true"{\textgreater}P{\textless}/mi{\textgreater}{\textless}/mrow{\textgreater}{\textless}mrow is="true"{\textgreater}{\textless}mn is="true"{\textgreater}6{\textless}/mn{\textgreater}{\textless}/mrow{\textgreater}{\textless}/msub{\textgreater}{\textless}/mrow{\textgreater}{\textless}/math{\textgreater} was conjectured by C̃ada et al. (2016).
A hole in a graph is a chordless cycle of length at least 4. A theta is a graph formed by three internally vertex-disjoint paths of length at least 2 between the same pair of distinct vertices. A wheel is a graph formed by a hole and a node that has at least 3 neighbors in the hole. In this series of papers we study the class of graphs that do not contain as an induced subgraph a theta nor a wheel. In Part II of the series we prove a decomposition theorem for this class, that uses clique cutsets and 2-joins. In this paper we use this decomposition theorem to solve several problems related to finding induced paths and cycles in our class.
A biclique of a graph G{\textless}math{\textgreater}{\textless}mi is="true"{\textgreater}G{\textless}/mi{\textgreater}{\textless}/math{\textgreater} is an induced complete bipartite subgraph of G{\textless}math{\textgreater}{\textless}mi is="true"{\textgreater}G{\textless}/mi{\textgreater}{\textless}/math{\textgreater} such that neither part is empty. A star is a biclique of G{\textless}math{\textgreater}{\textless}mi is="true"{\textgreater}G{\textless}/mi{\textgreater}{\textless}/math{\textgreater} such that one part has exactly one vertex. The star graph of G{\textless}math{\textgreater}{\textless}mi is="true"{\textgreater}G{\textless}/mi{\textgreater}{\textless}/math{\textgreater} is the intersection graph of the maximal stars of G{\textless}math{\textgreater}{\textless}mi is="true"{\textgreater}G{\textless}/mi{\textgreater}{\textless}/math{\textgreater}. A graph H{\textless}math{\textgreater}{\textless}mi is="true"{\textgreater}H{\textless}/mi{\textgreater}{\textless}/math{\textgreater} is star-critical if its star graph is different from the star graph of any of its proper induced subgraphs. We begin by showing that a star-critical pre-image of an n{\textless}math{\textgreater}{\textless}mi is="true"{\textgreater}n{\textless}/mi{\textgreater}{\textless}/math{\textgreater}-vertex star graph has at most On2{\textless}math{\textgreater}{\textless}mrow is="true"{\textgreater}{\textless}mi is="true" mathvariant="script"{\textgreater}O{\textless}/mi{\textgreater}{\textless}mfenced close=")" open="(" is="true"{\textgreater}{\textless}mrow is="true"{\textgreater}{\textless}msup is="true"{\textgreater}{\textless}mrow is="true"{\textgreater}{\textless}mi is="true"{\textgreater}n{\textless}/mi{\textgreater}{\textless}/mrow{\textgreater}{\textless}mrow is="true"{\textgreater}{\textless}mn is="true"{\textgreater}2{\textless}/mn{\textgreater}{\textless}/mrow{\textgreater}{\textless}/msup{\textgreater}{\textless}/mrow{\textgreater}{\textless}/mfenced{\textgreater}{\textless}/mrow{\textgreater}{\textless}/math{\textgreater}vertices. We then describe a Krausz-type characterization for star graphs. We combine these results to show that the problem of recognizing star graphs is in NP. We also present some properties of the class. In particular, we show that they are biconnected, that every edge belongs to at least one triangle, characterize the structures the pre-image must have in order to generate degree two vertices in its star graph, and bound the diameter of the star graph with respect to the diameter of its pre-image. Finally, we prove a monotonicity theorem, which we apply in order to list every star graph on at most eight vertices.},
	language = {en},
	number = {4},
	urldate = {2022-07-03},
	journal = {Information Processing Letters},
	author = {Roussopoulos, Nicholas D.},
	year = {1973},
	keywords = {automorphism, complete bipartite, complete graph, graph, maximal subgroup},
	pages = {108--112},
}

	month = oct,
@article{lehot_optimal_1974,
	title = {An {Optimal} {Algorithm} to {Detect} a {Line} {Graph} and {Output} {Its} {Root} {Graph}},
	volume = {21},
	issn = {0004-5411},
	url = {https://doi.org/10.1145/321850.321853},
	doi = {10.1145/321850.321853},
	abstract = {Given a graph H with E edges and N nodes, a graph G is sought such that H is the line graph of G, if G exists. The algorithm does this within the order of E steps, in fact in E + O(N) steps. This algorithm is optimal in its complexity.},
	number = {4},
	urldate = {2022-07-03},
	journal = {Journal of the ACM},
	author = {Lehot, Philippe G. H.},
	year = {1974},
	pages = {569--575},
}

  month = aug,
@article{syslo_labeling_1982,
	title = {A labeling algorithm to recognize a line digraph and output its root graph},
	volume = {15},
	issn = {0020-0190},
	url = {https://www.sciencedirect.com/science/article/pii/0020019082900801},
	doi = {10.1016/0020-0190(82)90080-1},
	abstract = {In this short note we present a very efficient, linear time algorithm for the recognition of line digraphs. The algorithm is based on a reformulation of the characterization of line digraphs proved by Harary and Norman.},
	language = {en},
	number = {1},
	urldate = {2022-07-03},
	journal = {Information Processing Letters},
	author = {Syslo, Maciej M.},
	year = {1982},
	keywords = {Line digraph, recognition algorithm},
	pages = {28--30},
}

	month = jun,
@inproceedings{degiorgi_dynamic_1995,
	address = {Berlin, Heidelberg},
	series = {{WG} '95},
	title = {A {Dynamic} {Algorithm} for {Line} {Graph} {Recognition}},
	isbn = {978-3-540-60618-5},
	urldate = {2022-07-03},
	booktitle = {Proceedings of the 21st {International} {Workshop} on {Graph}-{Theoretic} {Concepts} in {Computer} {Science}},
	publisher = {Springer-Verlag},
	author = {Degiorgi, Daniele Giorgio and Simon, Klaus},
	year = {1995},
	pages = {37--48},
}

	month = mar,
@article{liu_iligra_2015,
	title = {{ILIGRA}: {An} {Efficient} {Inverse} {Line} {Graph} {Algorithm}},
	volume = {14},
	issn = {2214-2495},
	shorttitle = {{ILIGRA}},
	url = {https://doi.org/10.1007/s10852-014-9251-2},
	doi = {10.1007/s10852-014-9251-2},
	abstract = {This paper presents a new and efficient algorithm, IligraLIGRA, for inverse line graph construction. Given a line graph H, ILIGRA constructs its root graph G with the time complexity being linear in the number of nodes in H. If ILIGRA does not know whether the given graph H is a line graph, it firstly assumes that H is a line graph and starts its root graph construction. During the root graph construction, ILIGRA checks whether the given graph H is a line graph and ILIGRA stops once it finds H is not a line graph. The time complexity of ILIGRA with line graph checking is linear in the number of links in the given graph H. For sparse line graphs of any size and for dense line graphs of small size, numerical results of the running time show that ILIGRA outperforms all currently available algorithms.},
	language = {en},
	number = {1},
	urldate = {2022-07-03},
	journal = {Journal of Mathematical Modelling and Algorithms in Operations Research},
	author = {Liu, Dajie and Trajanovski, Stojan and Van Mieghem, Piet},
	year = {2015},
	keywords = {Graph algorithm, Line graph, Root graph},
	pages = {13--33},
}

@article{poljak_complexity_1981,
	title = {Complexity of representation of graphs by set systems},
	volume = {3},
	issn = {0166218X},
	url = {https://linkinghub.elsevier.com/retrieve/pii/0166218X8190007X},
	doi = {10.1016/0166-218X(81)90007-X},
	language = {en},
	number = {4},
	urldate = {2022-07-03},
	journal = {Discrete Applied Mathematics},
	author = {Poljak, Svatopluk and Rödl, Vojtěch and Turzík, Daniel},
	month = nov,
	year = {1981},
	pages = {301--312},
}
